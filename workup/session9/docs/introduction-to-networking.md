[Main Menu](../../README.md) | [session9](../../session9/) | [Introduction to Networking](../docs/introduction-to-networking.md)

# Introduction to Networking

In this section we will give a basic introduction to `networking`, that is, how computers and devices communicate with each other over the Internet.

## Network protocol layers

Over the years there have been many networking technologies which have been standardised, widely adopted and later superseded by something better (e.g. Fibre, Frame Relay, ISDN, ATM, ADSL, Wifi, Dial up modems etc).
Engineers have found it useful to describe each of these technologies in terms of `network layers` starting with the  physical medium (Wireless, Electrical cables, Light) and rising to the application using the network (Web Browser, file transfer, video audio etc). 

A `network protocol` is a set of conventions governing the treatment and especially the formatting of data in an electronic communications system.
Each layer has its own `protocol` and it a well designed system, it should be possible to substitute one protocol in a given layer for another layer protocol without the layers above or below needing to be changed.
For example, your computer could connect to a wired `ethernet` network or to a wireless `wifi` network and apart from a change of IP address, the applications using the network connection will all continue to work the same way.

The most comprehensive model used for describing networks is the [OSI 7 Layer Model](https://en.wikipedia.org/wiki/OSI_model) but we will simplify this to just 4 layers in the following diagram.

![alt text](../docs/images/simplifiedNetworkLayers.drawio.png "simplifiedNetworkLayers.drawio.png")
References : 
[TCP (Wikipedia)](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)
[IPv4 (Wikipedia)](https://en.wikipedia.org/wiki/IPv4)
[Ethernet (Wikipedia)](https://en.wikipedia.org/wiki/Ethernet_frame)

### Link Layer

The link layer is used for point to point communications where the communicating devices send signals directly to each other.

All network communication is performed by sending a series of bytes serially as binary `1` or `0` symbols in a series of `frames` 
The `link layer` translates these signals into a form which can be transmitted across a `medium` which could be cable (Ethernet/ADSL), Air (wireless/wifi) or light (fibre).

Earlier we played with a simulated UART to print characters to a serial terminal.
This is a very simple link layer device where each frame is a single byte. 

![alt text](../docs/images/05_Understanding-UART_02_w640_hX.png "05_Understanding-UART_02_w640_hX.png")

The frame includes a single bit `parity checksum` which checks if there are an odd or even number of 1's in the data byte.
When the frame is received, the checksum is recalculated and if the bit doesn't match, the frame is discarded.
See [how a UART works](https://www.rohde-schwarz.com/uk/products/test-and-measurement/essentials-test-equipment/digital-oscilloscopes/understanding-uart_254524.html)

Ethernet is a widely used standard where the medium is `twisted pair cables`.
Ethernet describes a link layer frame of up to 1518 bytes. 

In an Ethernet network, all devices in a given `segment` can listen to all the messages transmitted on the segment. 

Every device on an Ethernet segment has a unique `Media Access Control (MAC) address` which is used by the receiving device to tell whether the message is for itself.
The `MAC Address` often set by the manufacturer and should be globally unique or at least unique within the segment.

When a device transmits a frame, it includes its own MAC address, the `source MAC address`, and the `destination MAC address` of the device it wants to talk to.

The frame also contains up to 1500 bytes of data and a 4 byte `checksum`.
The `checksum` is calculated using an algorithm which scans all of the data bytes in the frame. 
When a frame is received, the receiver also calculates the checksum and if the received checksum doesn't match the transmitted checksum, there is an error in transmission and the whole frame is discarded.


### Network Layer

The `network layer` is used to communicate across a network consisting of multiple `link layer` segments.

Frames generated by the `network layer` form the `payload` of link layer frames. 
Sometime the network layer frames (or `packets`) are too big for the link layer, in which case they are `fragmented` and joined back to together by the link layer.

The Internet V4 protocol defines a 32 bit IP address for each device in the network. 
Each network layer frame sent through the network has a `source IP address` and a `destination IP address`  which is used by the network layer to deliver the frame to the correct device. 

IPv4 addresses consist of 4 bytes which are typically written as 4 decimal numbers separated by full stops. 

Each number has a range from 0 to 255. e.g. `192.168.0.1` represents `11000000 10101000 00000000 00000001`

The original Internet design (IPv4) assumed 32 bits were thought to be enough to cover the number of computers in the world (4.3 billion addresses available).
Internet addresses are allocated globally by the Internet Assigned Numbers Authority (IANA) but the available address allocations began to be exhausted on 31 January 2011 (see [IPv4_address_exhaustion](https://en.wikipedia.org/wiki/IPv4_address_exhaustion))

Fortunately, IPv6 is being introduced which has a much larger address range.
An IPv6 address has 128-bits and is usually written in hex e.g. `2001:db8:3333:4444:5555:6666:7777:8888`
(We will just look at IPv4 for now).

`Routers` are devices in the network which collaborate to `route` packets from from router to router across the network to their final destination.

physical layer - Mac addresses
IP layer - Ip addresses

TCP/UDP  ports
NAT

finding other devices on the netowrk -ARP

routing tables
routing protocols

DNS - translating IP addresses to

# notes

on windows terminal try arp -a

```
PS C:\Users\cg02r> arp -a

Interface: 192.168.10.101 --- 0x12
  Internet Address      Physical Address      Type
  192.168.10.1          00-14-d1-57-11-ad     dynamic
  192.168.10.102        b8-27-eb-5b-24-76     dynamic
  192.168.10.255        ff-ff-ff-ff-ff-ff     static
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  224.0.0.252           01-00-5e-00-00-fc     static
  239.192.152.143       01-00-5e-40-98-8f     static
  239.255.255.250       01-00-5e-7f-ff-fa     static
  255.255.255.255       ff-ff-ff-ff-ff-ff     static
```

On pi try `arp -a` or `arp`

```
admin@raspberrypi01:~ $ arp -a
wstaff-79-128-1.solent.ac.uk (10.79.128.1) at b4:0c:25:e2:80:10 [ether] on wlan0
192-168-x-x.solent.ac.uk (192.168.10.1) at 00:14:d1:57:11:ad [ether] on eth0
192-168-x-x.solent.ac.uk (192.168.10.101) at 34:48:ed:03:cc:73 [ether] on eth0
admin@raspberrypi01:~ $ arp
Address                  HWtype  HWaddress           Flags Mask            Iface
wstaff-79-128-1.solent.  ether   b4:0c:25:e2:80:10   C                     wlan0
192-168-x-x.solent.ac.u  ether   00:14:d1:57:11:ad   C                     eth0
192-168-x-x.solent.ac.u  ether   34:48:ed:03:cc:73   C                     eth0
admin@raspberrypi01:~ $ ^C
admin@raspberrypi01:~ $ 

```

https://superuser.com/questions/29640/inverse-arp-lookup

https://www.networkworld.com/article/969445/checking-network-connections-with-arp-and-ip-neigh.html
